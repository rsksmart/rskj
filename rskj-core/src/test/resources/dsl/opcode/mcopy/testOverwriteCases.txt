comment

// CONTRACT CODE
//

// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.20;

contract TestMCopy {
    constructor() {}

    event ZERO_INPUTS_OK();
    event SINGLE_BYTE_REWRITE_OK();
    event FULL_WORD_REWRITE_OK();
    event SINGLE_BYTE_FWD_OVERWRITE_OK();
    event FULL_WORD_FWD_OVERWRITE_OK();
    event MID_WORD_SINGLE_BYTE_REWRITE_OK();
    event MID_WORD_SINGLE_WORD_REWRITE_OK();
    event MID_WORD_MULTY_WORD_REWRITE_OK();
    event TWO_WORDS_FWD_OVERWRITE_OK();
    event TWO_WORDS_BWD_OVERWRITE_OK();
    event TWO_WORDS_BWD_OVERWRITE_SINGLE_BYTE_OFFSET_OK();

    event ERROR();

    function runOverwriteCases() external {
        if (testZeroInputs()) {
            emit ZERO_INPUTS_OK();
            if (testSingleByteRewrite()) {
                emit SINGLE_BYTE_REWRITE_OK();
                if (testFullWordRewrite()) {
                    emit FULL_WORD_REWRITE_OK();
                    if (testSingleByteFwdOverwrite()) {
                        emit SINGLE_BYTE_FWD_OVERWRITE_OK();
                        if (testFullWordFwdOverwrite()) {
                            emit FULL_WORD_FWD_OVERWRITE_OK();
                            if (testMidWordSingleByteRewrite()) {
                                emit MID_WORD_SINGLE_BYTE_REWRITE_OK();
                                if (testMidWordSingleWordRewrite()) {
                                    emit MID_WORD_SINGLE_WORD_REWRITE_OK();
                                    if (testMidWordMultiWordRewrite()) {
                                        emit MID_WORD_MULTY_WORD_REWRITE_OK();
                                        if (testTwoWordsFwdOverwrite()) {
                                            emit TWO_WORDS_FWD_OVERWRITE_OK();
                                            if (testTwoWordsBwdOverwrite()) {
                                                emit TWO_WORDS_BWD_OVERWRITE_OK();
                                                if (testTwoWordsBwdOverwriteSingleByteOffset()) {
                                                    emit TWO_WORDS_BWD_OVERWRITE_SINGLE_BYTE_OFFSET_OK();
                                                    return;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        emit ERROR();
    }

    function testZeroInputs() public pure returns (bool status) {
        bytes32 initialValue = 0x0001020304050607080900000000000000000000000000000000000000000000;
        bytes32 result;
        assembly {
            mstore(0, initialValue) // Initialize memory with a word at offset 0
            mcopy(0, 0, 0)          // Use MCOPY to copy 0 bytes starting from offset 0 to offset 0 in memory
            result := mload(0)      // Assigns the word starting at offset 0 to result
        }
        status = (result == initialValue);
    }

    function testSingleByteRewrite() public pure returns (bool status) {
        bytes32 initialValue = 0x0001020304050607080900000000000000000000000000000000000000000000;
        bytes32 result;
        assembly {
            mstore(0, initialValue) // Initialize memory with a word at offset 0
            mcopy(0, 0, 1)          // Use MCOPY to copy 1 byte starting from offset 0 to offset 0 in memory
            result := mload(0)      // Assigns the word starting at offset 0 to result
        }
        status = (result == initialValue);
    }

    function testFullWordRewrite() public pure returns (bool status) {
        bytes32 initialValue = 0x0001020304050607080900000000000000000000000000000000000000000000;
        bytes32 result;
        assembly {
            mstore(0, initialValue) // Initialize memory with a word at offset 0
            mcopy(0, 0, 32)         // Use MCOPY to copy 32 bytes starting from offset 0 to offset 0 in memory
            result := mload(0)      // Assigns the word starting at offset 0 to result
        }
        status = (result == initialValue);
    }

    function testSingleByteFwdOverwrite() public pure returns (bool status) {
        bytes32 initialValue  = 0x0001020304050607080900000000000000000000000000000000000000000000;
        bytes32 expectedValue = 0x0000020304050607080900000000000000000000000000000000000000000000;
        bytes32 result;
        assembly {
            mstore(0, initialValue) // Initialize memory with a word at offset 0
            mcopy(1, 0, 1)          // Use MCOPY to copy 1 byte starting from offset 0 to offset 1 in memory
            result := mload(0)      // Assigns the word starting at offset 0 to result
        }
        status = (result == expectedValue);
    }

    function testFullWordFwdOverwrite() public pure returns (bool status) {
        bytes32 initialValue  = 0x0001020304050607080900000000000000000000000000000000000000000000;
        bytes32 expectedValue = 0x0000010203040506070809000000000000000000000000000000000000000000;
        bytes32 result;
        assembly {
            mstore(0, initialValue) // Initialize memory with a word at offset 0
            mcopy(1, 0, 32)         // Use MCOPY to copy 32 bytes starting from offset 0 to offset 1 in memory
            result := mload(0)      // Assigns the word starting at offset 0 to result
        }
        status = (result == expectedValue);
    }

    function testMidWordSingleByteRewrite() public pure returns (bool status) {
        bytes32 initialValue  = 0x000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f;
        bytes32 expectedValue = 0x000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f;
        bytes32 result;
        assembly {
            mstore(0, initialValue) // Initialize memory with a word at offset 0
            mcopy(17, 17, 1)        // Use MCOPY to copy 1 byte starting from offset 17 to offset 17 in memory
            result := mload(0)      // Assigns the word starting at offset 0 to result
        }
        status = (result == expectedValue);
    }

    function testMidWordSingleWordRewrite() public pure returns (bool status) {
        bytes32 word1         = 0x000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f;
        bytes32 word2         = 0x202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f;
        bytes32 expectedValue = 0x000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f;
        bytes32 result;
        assembly {
            mstore(0, word1)   // Initialize memory with a word at offset 0
            mstore(32, word2)  // Add more memory with a word at offset 32
            mcopy(17, 17, 32)  // Use MCOPY to copy 32 bytes starting from offset 17 to offset 17 in memory
            result := mload(0) // Assigns the word starting at offset 0 to result
        }
        status = (result == expectedValue);
    }

    function testMidWordMultiWordRewrite() public pure returns (bool status) {
        bytes32 word1          = 0x000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f;
        bytes32 word2          = 0x202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f;
        bytes32 word3          = 0x404142434445464748494a4b4c4d4e4f505152535455565758595a5b5c5d5e5f;
        bytes32 result1;
        bytes32 result2;
        bytes32 result3;
        assembly {
            mstore(0, word1)     // Initialize memory with a word at offset 0
            mstore(32, word2)    // Add more memory with a word at offset 32
            mstore(64, word3)    // Add more memory with a word at offset 64
            mcopy(17, 17, 64)    // Use MCOPY to copy 64 bytes starting from offset 17 to offset 17 in memory
            result1 := mload(0)  // Assigns the word starting at offset 0 to result1
            result2 := mload(32) // Assigns the word starting at offset 32 to result2
            result3 := mload(64) // Assigns the word starting at offset 64 to result3
        }
        status = (result1 == word1 && result2 == word2 && result3 == word3);
    }

    function testTwoWordsFwdOverwrite() public pure returns (bool status) {
        bytes32 word1          = 0x000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f;
        bytes32 word2          = 0x202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f;
        bytes32 word3          = 0x404142434445464748494a4b4c4d4e4f505152535455565758595a5b5c5d5e5f;
        bytes32 expectedValue1 = 0x000102030405060708090a0b0c0d0e0f000102030405060708090a0b0c0d0e0f;
        bytes32 expectedValue2 = 0x101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f;
        bytes32 expectedValue3 = 0x303132333435363738393a3b3c3d3e3f505152535455565758595a5b5c5d5e5f;
        bytes32 result1;
        bytes32 result2;
        bytes32 result3;
        assembly {
            mstore(0, word1)     // Initialize memory with a word at offset 0
            mstore(32, word2)    // Add more memory with a word at offset 32
            mstore(64, word3)    // Add more memory with a word at offset 64
            mcopy(16, 0, 64)     // Use MCOPY to copy 64 bytes starting from offset 0 to offset 16 in memory
            result1 := mload(0)  // Assigns the word starting at offset 0 to result1
            result2 := mload(32) // Assigns the word starting at offset 32 to result2
            result3 := mload(64) // Assigns the word starting at offset 64 to result3
        }
        status = (result1 == expectedValue1 && result2 == expectedValue2 && result3 == expectedValue3);
    }

    function testTwoWordsBwdOverwrite() public pure returns (bool status) {
        bytes32 word1          = 0x000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f;
        bytes32 word2          = 0x202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f;
        bytes32 word3          = 0x404142434445464748494a4b4c4d4e4f505152535455565758595a5b5c5d5e5f;
        bytes32 expectedValue1 = 0x000102030405060708090a0b0c0d0e0f000102030405060708090a0b0c0d0e0f;
        bytes32 expectedValue2 = 0x101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f;
        bytes32 expectedValue3 = 0x303132333435363738393a3b3c3d3e3f505152535455565758595a5b5c5d5e5f;
        bytes32 result1;
        bytes32 result2;
        bytes32 result3;
        assembly {
            mstore(0, word1)     // Initialize memory with a word at offset 0
            mstore(32, word2)    // Add more memory with a word at offset 32
            mstore(64, word3)    // Add more memory with a word at offset 64
            mcopy(16, 0, 64)     // Use MCOPY to copy 64 bytes starting from offset 0 to offset 16 in memory
            result1 := mload(0)  // Assigns the word starting at offset 0 to result1
            result2 := mload(32) // Assigns the word starting at offset 32 to result2
            result3 := mload(64) // Assigns the word starting at offset 64 to result3
        }
        status = (result1 == expectedValue1 && result2 == expectedValue2 && result3 == expectedValue3);
    }

    function testTwoWordsBwdOverwriteSingleByteOffset() public pure returns (bool status) {
        bytes32 word1          = 0x000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f;
        bytes32 word2          = 0x202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f;
        bytes32 word3          = 0x404142434445464748494a4b4c4d4e4f505152535455565758595a5b5c5d5e5f;
        bytes32 expectedValue1 = 0x000102030405060708090a0b0c0d0e101112131415161718191a1b1c1d1e1f20;
        bytes32 expectedValue2 = 0x2122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f40;
        bytes32 expectedValue3 = 0x4142434445464748494a4b4c4d4e4f4f505152535455565758595a5b5c5d5e5f;
        bytes32 result1;
        bytes32 result2;
        bytes32 result3;
        assembly {
            mstore(0, word1)     // Initialize memory with a word at offset 0
            mstore(32, word2)    // Add more memory with a word at offset 32
            mstore(64, word3)    // Add more memory with a word at offset 64
            mcopy(15, 16, 64)    // Use MCOPY to copy 64 bytes starting from offset 16 to offset 15 in memory
            result1 := mload(0)  // Assigns the word starting at offset 0 to result1
            result2 := mload(32) // Assigns the word starting at offset 32 to result2
            result3 := mload(64) // Assigns the word starting at offset 64 to result3
        }
        status = (result1 == expectedValue1 && result2 == expectedValue2 && result3 == expectedValue3);
    }

}

// DESCRIPTION

This contract contains two types of functions:

* runAdvancedCases runs the individual tests (failing fast) and:
    - Emits an OK event for each test that was successfully executed.
    - Emits an ERROR as soon as some test fails.

* test<TestName> manage the memory by storing, copying and reading values as needed for the case.

// CONTRACT BYTECODE

6080604052348015600e575f80fd5b50610bcf8061001c5f395ff3fe608060405234801561000f575f80fd5b50600436106100b1575f3560e01c8063960958e51161006f578063960958e514610155578063ab6707f514610173578063af9fafca14610191578063c16527b5146101af578063dde848ce146101cd578063e67db72b146101eb576100b1565b80624aa044146100b5578063190fef25146100d35780632b803126146100f15780632bccb6691461010f5780633f2a93c51461012d578063942e95561461014b575b5f80fd5b6100bd610209565b6040516100ca9190610b80565b60405180910390f35b6100db610335565b6040516100e89190610b80565b60405180910390f35b6100f9610462565b6040516101069190610b80565b60405180910390f35b61011761058e565b6040516101249190610b80565b60405180910390f35b6101356105f2565b6040516101429190610b80565b60405180910390f35b6101536106aa565b005b61015d61095b565b60405161016a9190610b80565b60405180910390f35b61017b6109ea565b6040516101889190610b80565b60405180910390f35b610199610a26565b6040516101a69190610b80565b60405180910390f35b6101b7610a89565b6040516101c49190610b80565b60405180910390f35b6101d5610aec565b6040516101e29190610b80565b60405180910390f35b6101f3610b29565b6040516102009190610b80565b60405180910390f35b5f807e0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f5f1b90505f7f202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f5f1b90505f7f404142434445464748494a4b4c4d4e4f505152535455565758595a5b5c5d5e5f5f1b90505f7e0102030405060708090a0b0c0d0e0f000102030405060708090a0b0c0d0e0f5f1b90505f7f101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f5f1b90505f7f303132333435363738393a3b3c3d3e3f505152535455565758595a5b5c5d5e5f5f1b90505f805f885f52876020528660405260405f60105e5f51925060205191506040519050858314801561031c57508482145b801561032757508381145b995050505050505050505090565b5f807e0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f5f1b90505f7f202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f5f1b90505f7f404142434445464748494a4b4c4d4e4f505152535455565758595a5b5c5d5e5f5f1b90505f7e0102030405060708090a0b0c0d0e101112131415161718191a1b1c1d1e1f205f1b90505f7f2122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f405f1b90505f7f4142434445464748494a4b4c4d4e4f4f505152535455565758595a5b5c5d5e5f5f1b90505f805f885f52876020528660405260406010600f5e5f51925060205191506040519050858314801561044957508482145b801561045457508381145b995050505050505050505090565b5f807e0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f5f1b90505f7f202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f5f1b90505f7f404142434445464748494a4b4c4d4e4f505152535455565758595a5b5c5d5e5f5f1b90505f7e0102030405060708090a0b0c0d0e0f000102030405060708090a0b0c0d0e0f5f1b90505f7f101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f5f1b90505f7f303132333435363738393a3b3c3d3e3f505152535455565758595a5b5c5d5e5f5f1b90505f805f885f52876020528660405260405f60105e5f51925060205191506040519050858314801561057557508482145b801561058057508381145b995050505050505050505090565b5f807e0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f5f1b90505f7e0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f5f1b90505f825f5260016011805e5f519050818114935050505090565b5f807e0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f5f1b90505f7f202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f5f1b90505f7f404142434445464748494a4b4c4d4e4f505152535455565758595a5b5c5d5e5f5f1b90505f805f855f52846020528360405260406011805e5f51925060205191506040519050858314801561069457508482145b801561069f57508381145b965050505050505090565b6106b26109ea565b1561092c577f6f4d0d238fff0175b16cb83021c4b659ea083bffe875b6af90747bb8de77808860405160405180910390a16106eb610b29565b1561092b577f73d3f9a883b7d82f7ff3e14f66d5f8c3aa4479c9023a0767a806ef70cc47230360405160405180910390a1610724610aec565b1561092a577fdd983e940817071ed50d8f612cc4b6e3b38422b4f9db00e8afcf97e941b9f58860405160405180910390a161075d610a89565b15610929577f50c03b0095f7485c8af592a8df05acddc51459fc47678cc80643748a5045d8d060405160405180910390a1610796610a26565b15610928577f44c6943968f28dcc072b103b38a00777b96ca694433fa6f1582fd8bef8ee290e60405160405180910390a16107cf61058e565b15610927577ff8501af18168a96bcaf17f9d8ea891cfd963ed0e605cb681ef58b0dad711047d60405160405180910390a161080861095b565b15610926577f4a28baee79ceb4fc5da8fdbb3a482c7700a0f5406ba8e2849741bcd49e88f74160405160405180910390a16108416105f2565b15610925577fa6d79b32f273252d1504fbeea7f68c57633aa4fdc721493f9d435ac9795f28b460405160405180910390a161087a610209565b15610924577fd8c4eae993ca99cd0e2e16294175b57c2e3854b69c736fc9ba638eb9bb5abfe660405160405180910390a16108b3610462565b15610923577fbdd8f7a05848307eab4cdca691861ed1955df075139db8c6ea0a5f7d7631bd8160405160405180910390a16108ec610335565b15610922577f964126d4996bcf352c3ffa136cee5e184ee5353ada375004bc8ea03a44f4c9b660405160405180910390a1610959565b5b5b5b5b5b5b5b5b5b5b7f1c9c433b57013295d61f5c5738f5e2cb1de70bb5ba5b2896edfa8efae345965e60405160405180910390a15b565b5f807e0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f5f1b90505f7f202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f5f1b90505f7e0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f5f1b90505f835f528260205260206011805e5f51905081811494505050505090565b5f807e010203040506070809000000000000000000000000000000000000000000005f1b90505f815f525f805f5e5f5190508181149250505090565b5f807e010203040506070809000000000000000000000000000000000000000000005f1b90505f7d0102030405060708090000000000000000000000000000000000000000005f1b90505f825f5260205f60015e5f519050818114935050505090565b5f807e010203040506070809000000000000000000000000000000000000000000005f1b90505f7d0203040506070809000000000000000000000000000000000000000000005f1b90505f825f5260015f60015e5f519050818114935050505090565b5f807e010203040506070809000000000000000000000000000000000000000000005f1b90505f815f5260205f805e5f5190508181149250505090565b5f807e010203040506070809000000000000000000000000000000000000000000005f1b90505f815f5260015f805e5f5190508181149250505090565b5f8115159050919050565b610b7a81610b66565b82525050565b5f602082019050610b935f830184610b71565b9291505056fea26469706673582212200e7955b8113336ae846ffeb55d541f54584c0fc5800e2bebf58caea89643135664736f6c634300081a0033

// CONTRACT CALL

- runOverwriteCases()

    942e9556

end

# Create and fund new account
account_new acc1 10000000

# Create transaction to deploy TestMCopy contract
transaction_build txTestMCopy
    sender acc1
    receiverAddress 00
    value 0
    data 6080604052348015600e575f80fd5b50610bcf8061001c5f395ff3fe608060405234801561000f575f80fd5b50600436106100b1575f3560e01c8063960958e51161006f578063960958e514610155578063ab6707f514610173578063af9fafca14610191578063c16527b5146101af578063dde848ce146101cd578063e67db72b146101eb576100b1565b80624aa044146100b5578063190fef25146100d35780632b803126146100f15780632bccb6691461010f5780633f2a93c51461012d578063942e95561461014b575b5f80fd5b6100bd610209565b6040516100ca9190610b80565b60405180910390f35b6100db610335565b6040516100e89190610b80565b60405180910390f35b6100f9610462565b6040516101069190610b80565b60405180910390f35b61011761058e565b6040516101249190610b80565b60405180910390f35b6101356105f2565b6040516101429190610b80565b60405180910390f35b6101536106aa565b005b61015d61095b565b60405161016a9190610b80565b60405180910390f35b61017b6109ea565b6040516101889190610b80565b60405180910390f35b610199610a26565b6040516101a69190610b80565b60405180910390f35b6101b7610a89565b6040516101c49190610b80565b60405180910390f35b6101d5610aec565b6040516101e29190610b80565b60405180910390f35b6101f3610b29565b6040516102009190610b80565b60405180910390f35b5f807e0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f5f1b90505f7f202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f5f1b90505f7f404142434445464748494a4b4c4d4e4f505152535455565758595a5b5c5d5e5f5f1b90505f7e0102030405060708090a0b0c0d0e0f000102030405060708090a0b0c0d0e0f5f1b90505f7f101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f5f1b90505f7f303132333435363738393a3b3c3d3e3f505152535455565758595a5b5c5d5e5f5f1b90505f805f885f52876020528660405260405f60105e5f51925060205191506040519050858314801561031c57508482145b801561032757508381145b995050505050505050505090565b5f807e0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f5f1b90505f7f202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f5f1b90505f7f404142434445464748494a4b4c4d4e4f505152535455565758595a5b5c5d5e5f5f1b90505f7e0102030405060708090a0b0c0d0e101112131415161718191a1b1c1d1e1f205f1b90505f7f2122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f405f1b90505f7f4142434445464748494a4b4c4d4e4f4f505152535455565758595a5b5c5d5e5f5f1b90505f805f885f52876020528660405260406010600f5e5f51925060205191506040519050858314801561044957508482145b801561045457508381145b995050505050505050505090565b5f807e0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f5f1b90505f7f202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f5f1b90505f7f404142434445464748494a4b4c4d4e4f505152535455565758595a5b5c5d5e5f5f1b90505f7e0102030405060708090a0b0c0d0e0f000102030405060708090a0b0c0d0e0f5f1b90505f7f101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f5f1b90505f7f303132333435363738393a3b3c3d3e3f505152535455565758595a5b5c5d5e5f5f1b90505f805f885f52876020528660405260405f60105e5f51925060205191506040519050858314801561057557508482145b801561058057508381145b995050505050505050505090565b5f807e0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f5f1b90505f7e0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f5f1b90505f825f5260016011805e5f519050818114935050505090565b5f807e0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f5f1b90505f7f202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f5f1b90505f7f404142434445464748494a4b4c4d4e4f505152535455565758595a5b5c5d5e5f5f1b90505f805f855f52846020528360405260406011805e5f51925060205191506040519050858314801561069457508482145b801561069f57508381145b965050505050505090565b6106b26109ea565b1561092c577f6f4d0d238fff0175b16cb83021c4b659ea083bffe875b6af90747bb8de77808860405160405180910390a16106eb610b29565b1561092b577f73d3f9a883b7d82f7ff3e14f66d5f8c3aa4479c9023a0767a806ef70cc47230360405160405180910390a1610724610aec565b1561092a577fdd983e940817071ed50d8f612cc4b6e3b38422b4f9db00e8afcf97e941b9f58860405160405180910390a161075d610a89565b15610929577f50c03b0095f7485c8af592a8df05acddc51459fc47678cc80643748a5045d8d060405160405180910390a1610796610a26565b15610928577f44c6943968f28dcc072b103b38a00777b96ca694433fa6f1582fd8bef8ee290e60405160405180910390a16107cf61058e565b15610927577ff8501af18168a96bcaf17f9d8ea891cfd963ed0e605cb681ef58b0dad711047d60405160405180910390a161080861095b565b15610926577f4a28baee79ceb4fc5da8fdbb3a482c7700a0f5406ba8e2849741bcd49e88f74160405160405180910390a16108416105f2565b15610925577fa6d79b32f273252d1504fbeea7f68c57633aa4fdc721493f9d435ac9795f28b460405160405180910390a161087a610209565b15610924577fd8c4eae993ca99cd0e2e16294175b57c2e3854b69c736fc9ba638eb9bb5abfe660405160405180910390a16108b3610462565b15610923577fbdd8f7a05848307eab4cdca691861ed1955df075139db8c6ea0a5f7d7631bd8160405160405180910390a16108ec610335565b15610922577f964126d4996bcf352c3ffa136cee5e184ee5353ada375004bc8ea03a44f4c9b660405160405180910390a1610959565b5b5b5b5b5b5b5b5b5b5b7f1c9c433b57013295d61f5c5738f5e2cb1de70bb5ba5b2896edfa8efae345965e60405160405180910390a15b565b5f807e0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f5f1b90505f7f202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f5f1b90505f7e0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f5f1b90505f835f528260205260206011805e5f51905081811494505050505090565b5f807e010203040506070809000000000000000000000000000000000000000000005f1b90505f815f525f805f5e5f5190508181149250505090565b5f807e010203040506070809000000000000000000000000000000000000000000005f1b90505f7d0102030405060708090000000000000000000000000000000000000000005f1b90505f825f5260205f60015e5f519050818114935050505090565b5f807e010203040506070809000000000000000000000000000000000000000000005f1b90505f7d0203040506070809000000000000000000000000000000000000000000005f1b90505f825f5260015f60015e5f519050818114935050505090565b5f807e010203040506070809000000000000000000000000000000000000000000005f1b90505f815f5260205f805e5f5190508181149250505090565b5f807e010203040506070809000000000000000000000000000000000000000000005f1b90505f815f5260015f805e5f5190508181149250505090565b5f8115159050919050565b610b7a81610b66565b82525050565b5f602082019050610b935f830184610b71565b9291505056fea26469706673582212200e7955b8113336ae846ffeb55d541f54584c0fc5800e2bebf58caea89643135664736f6c634300081a0033
    gas 750000
    build

# Create block to hold txTestMCopy transaction
block_build b01
    parent g00
    transactions txTestMCopy
    build

# Connect block
block_connect b01

# Check b01 is best block
assert_best b01

# Check txTestMCopy succeeded
assert_tx_success txTestMCopy

# Create transaction to execute checkMCopy() method
transaction_build txTestMCopyOKCall
    sender acc1
    nonce 1
    contract txTestMCopy
    value 0
    data 942e9556
    gas 100000
    build

# Create block to hold txTestMCopyOKCall transaction
block_build b02
    parent b01
    transactions txTestMCopyOKCall
    gasLimit 100000
    build

# Connect block
block_connect b02

# Check b02 is best block
assert_best b02

# Check txTestMCopyOKCall succeeded
assert_tx_success txTestMCopyOKCall