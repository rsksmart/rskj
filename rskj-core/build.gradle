plugins {
    id 'application'
    id 'checkstyle'
    id "com.diffplug.spotless" version "6.13.0"
    id 'java'
}

apply from: 'src/fuzzTest/fuzzing.gradle'
apply plugin: 'maven-publish'
apply plugin: 'jacoco'

import java.nio.file.Paths

// Define static timestamp
def staticTimestamp = '2024-10-31T10:24:00'
ext.timestamp = staticTimestamp

def filteredFiles = getFilteredFiles()

checkstyle {
    toolVersion = '8.45'
    configFile = file("$rootDir/config/checkstyle/checkstyle.xml")
}

spotless {
    enforceCheck false
    java {
        // Only check for newline at end of file
        endWithNewline()
        target filteredFiles
        // Enable ratchet mode to only check files changed from the target branch
        if (project.hasProperty('ratchetFrom')) {
            ratchetFrom project.property('ratchetFrom')
        }
    }
}

java {
    sourceCompatibility = JavaVersion.VERSION_17
    targetCompatibility = JavaVersion.VERSION_17
}

application {
    mainClass = 'co.rsk.Start'
    applicationDefaultJvmArgs = ["-server", "-Xss32m", "-Xms3G", "-Xmx5G", "-XX:+UseCompressedOops", "-XX:-OmitStackTraceInFastThrow"]
}

def getFilteredFiles() {
    def timestamp = ext.timestamp

    def commandLog = [
            'git', 'log', '--since=' + timestamp, '--name-only', '--pretty=format:', '--abbrev-commit'
    ]
    def commandDiff = [
            'git', 'diff', '--name-only'
    ]
    def commandStaged = [
            'git', 'diff', '--cached', '--name-only'
    ]

    def outputLog = new ByteArrayOutputStream()
    def outputDiff = new ByteArrayOutputStream()
    def outputStaged = new ByteArrayOutputStream()

    exec {
        commandLine commandLog
        standardOutput = outputLog
        errorOutput = outputLog
        ignoreExitValue = true
    }

    exec {
        commandLine commandDiff
        standardOutput = outputDiff
        errorOutput = outputDiff
        ignoreExitValue = true
    }

    exec {
        commandLine commandStaged
        standardOutput = outputStaged
        errorOutput = outputStaged
        ignoreExitValue = true
    }

    def committedFiles = outputLog.toString().trim().split('\n').toList().unique()
    def uncommittedFiles = outputDiff.toString().trim().split('\n').toList().unique()
    def stagedFiles = outputStaged.toString().trim().split('\n').toList().unique()
    def allFiles = committedFiles + uncommittedFiles + stagedFiles

    allFiles = allFiles.unique().findAll { file -> file }

    def projectRoot = project.projectDir.toPath().toAbsolutePath()

    allFiles = allFiles.findAll { file ->
        file.endsWith('.java')
    }.collect { file ->
        def relativePath = Paths.get(file).subpath(1, Paths.get(file).getNameCount()) // Adjust the subpath as necessary
        def absolutePath = projectRoot.resolve(relativePath).toFile()

        return absolutePath.exists() ? absolutePath : null
    }.findAll { it != null }

    return allFiles
}


def configureCheckstyleTask(Checkstyle task, String sourceDir) {
    // For checkstyleFile task, the sources are set via -PfilePath parameter in task definition
    if (task.name == 'checkstyleFile' && !project.hasProperty('filePath')) {
        println "No filePath property provided. Skipping task ${task.name}"
        task.enabled = false
        return
    }

    def filteredFilesCheckstyle = task.name == 'checkstyleFile'
        ? project.property('filePath').split(',').collect { it.trim() }
        : getFilteredFilesForCheckstyle(sourceDir)

    if (!filteredFilesCheckstyle.isEmpty()) {
        task.source = project.files(filteredFilesCheckstyle)
    } else {
        println "No files to assign to Checkstyle for ${sourceDir}. Skipping task."
        task.enabled = false
    }

    task.classpath = project.files(
            sourceSets.main.output.classesDirs,
            sourceSets.main.output.resourcesDir
    )
    task.reports {
        xml.required.set(true)
        html.required.set(true)
    }
    task.onlyIf {
        !filteredFilesCheckstyle.isEmpty()
    }
}

def getFilteredFilesForCheckstyle(String sourceDir) {
    def files = getFilteredFiles()
    return files.findAll { file ->
        def filePath = file.toPath().normalize()
        def isJavaFile = filePath.toString().endsWith('.java')
        def containsSourceSegment = filePath.toString().contains(sourceDir)

        isJavaFile && containsSourceSegment
    }
}


// Configure each Checkstyle task
tasks.withType(Checkstyle).configureEach { Checkstyle task ->
    def sourceDirMapping = [
            'checkstyleMain'           : 'src/main/java',
            'checkstyleTest'           : 'src/test/java',
            'checkstyleIntegrationTest': 'src/integrationTest/java',
            'checkstyleJmh'            : 'src/jmh/java',
            'checkstyleFuzz'           : 'src/fuzzTest/java',
            'checkstyleFile'           : ''
    ]

    sourceDirMapping.each { taskName, sourceDir ->
        if (task.name == taskName) {
            configureCheckstyleTask(task, sourceDir)
        }
    }

    if (task.name in ['checkstyleJmh', 'checkstyleIntegrationTest']) {
        task.doFirst {
            def relevantSourceDir = task.name == 'checkstyleJmh' ? 'src/jmh/java' : 'src/integrationTest/java'
            def checkstyleFiles = getFilteredFilesForCheckstyle(relevantSourceDir)

            if (!checkstyleFiles.isEmpty()) {
                task.source = project.files(checkstyleFiles)
            }
        }
    }
    task.dependsOn processResources
}

configurations {
    jmh
}

sourceSets {
    jmh {
        java {
            srcDirs = ['src/jmh/java']
        }
        resources {
            srcDirs = ['src/jmh/resources']
        }
    }
    fuzzTest {
        java {
            srcDirs = ['src/fuzzTest/java']
        }
        resources {
            srcDirs = ['src/fuzzTest/resources']
        }
        compileClasspath += sourceSets.main.output + sourceSets.test.output
        runtimeClasspath += sourceSets.main.output + sourceSets.test.output
    }
}

testing {
    suites {
        integrationTest(JvmTestSuite) {
            dependencies {
                implementation project()
            }
        }
    }
}

test {
    useJUnitPlatform()

    beforeTest { descriptor ->
        logger.lifecycle("Running test: ${descriptor}")
    }

    jvmArgs '-Xss32m', '-Xmx4G'

    testLogging {
        events "failed"
        exceptionFormat "short"
    }
    finalizedBy jacocoTestReport
}

integrationTest {
    dependsOn assemble

    beforeTest { descriptor ->
        logger.lifecycle("Running integration test: ${descriptor}")
    }
}

jacocoTestReport {
    reports {
        xml.required = true
    }
    sourceSets sourceSets.main, sourceSets.fuzzTest
}

task parallelTest(type: Test) {
    useJUnitPlatform()
    //increase heap memory
    jvmArgs '-Xss64m', '-Xmx4G'
    //stop build after the first failing test
    failFast = project.hasProperty("failFast")
    //option to use the half of the available cores (it can be increased but there is no too much difference)
    maxParallelForks = Runtime.runtime.availableProcessors().intdiv(2) ?: 1
    //this is recommended in the docs, -> https://docs.gradle.org/current/userguide/performance.html#forking_options
    forkEvery = 750
    //save some time avoiding reports
    reports.html.required = false
    reports.junitXml.required = false
}

tasks.withType(Javadoc) {
    options.addStringOption('Xdoclint:none', '-quiet')
}

repositories {
    mavenCentral()
    gradlePluginPortal()
    maven {
        url "https://deps.rsklabs.io"
    }
}

tasks.withType(JavaCompile) {
    options.warnings = false
    options.encoding = 'UTF-8'
    options.compilerArgs << '-XDignore.symbol.file' // << "-Xlint:unchecked" << "-Xlint:deprecation"
}

tasks.withType(AbstractArchiveTask) {
    preserveFileTimestamps = false
    reproducibleFileOrder = true

    dirMode = 0775
    fileMode = 0664
}

tasks.matching { it.name.contains("Fuzz") && it instanceof Test }.configureEach {
    ignoreFailures = true
}

ext {
    libVersions = [
            nettyVer             : '4.1.78.Final',
            spongyCastleVer      : '1.58.0.0',
            bouncyCastleVer      : '1.59',
            ethereumLeveldbJniVer: '1.18.3',
            rocksdbJniVer        : '7.10.2',
            slf4jVer             : '1.7.36',
            logbackVer           : '1.2.10',
            jacksonVer           : '2.15.4',
            commonsLang3Ver      : '3.12.0',
            typesafeConfigVer    : '1.4.2',
            mapdbVer             : '2.0-beta13',
            jsonrpc4jVer         : '1.6',
            jaxwsRtVer           : '2.3.5',
            picocliVer           : '4.6.3',

            bitcoinjThinVer: '0.14.4-rsk-18',
            rskjNativeVer: '1.3.0',
    ]

    libs = [
            nettyLib             : "io.netty:netty-codec-http:${libVersions.nettyVer}",
            spongyCastleLib      : "com.madgag.spongycastle:core:${libVersions.spongyCastleVer}",
            bouncyCastleLib      : "org.bouncycastle:bclcrypto-jdk15on:${libVersions.bouncyCastleVer}",
            ethereumLeveldbJniLib: "org.ethereum:leveldbjni-all:${libVersions.ethereumLeveldbJniVer}",
            rocksdbJniLib        : "org.rocksdb:rocksdbjni:${libVersions.rocksdbJniVer}",
            slf4jApiLib          : "org.slf4j:slf4j-api:${libVersions.slf4jVer}",
            log4jOverSlf4jLib    : "org.slf4j:log4j-over-slf4j:${libVersions.slf4jVer}",
            logbackCoreLib       : "ch.qos.logback:logback-core:${libVersions.logbackVer}",
            logbackClassicLib    : "ch.qos.logback:logback-classic:${libVersions.logbackVer}",
            jacksonLib           : "com.fasterxml.jackson.core:jackson-databind:${libVersions.jacksonVer}",
            commonsLang3Lib      : "org.apache.commons:commons-lang3:${libVersions.commonsLang3Ver}",
            typesafeConfigLib    : "com.typesafe:config:${libVersions.typesafeConfigVer}",
            mapdbLib             : "org.mapdb:mapdb:${libVersions.mapdbVer}",
            jsonrpc4jLib         : "com.github.briandilley.jsonrpc4j:jsonrpc4j:${libVersions.jsonrpc4jVer}",
            jaxwsRtLib           : "com.sun.xml.ws:jaxws-rt:${libVersions.jaxwsRtVer}",
            picocliLib           : "info.picocli:picocli:${libVersions.picocliVer}",

            bitcoinjThinLib      : "co.rsk.bitcoinj:bitcoinj-thin:${libVersions.bitcoinjThinVer}",
            rskjNativeLib        : "co.rsk:native:${libVersions.rskjNativeVer}",
    ]

    testLibVersions = [
            junitVer         : '5.10.3',
            junitSuiteVer    : '1.10.3',
            mockitoInlineVer : '5.2.0',
            mockitoJupiterVer: '5.12.0',
            awaitilityVer    : '4.2.0',
            commonsIoVer     : '2.11.0',
            commonsCodecVer  : '1.15',
            jacksonVer       : '2.15.4',
            okhttpWsVer      : '2.7.5',

            rskLllVer        : '0.0.2',

            jazzerJunitVer   : '0.24.0',
    ]

    jmhLibVersions = [
            jmh  : "1.36",
            web3j: "4.9.8",
    ]

    testLibs = [
            junitLib       : "org.junit.jupiter:junit-jupiter-engine:${testLibVersions.junitVer}",
            junitParams    : "org.junit.jupiter:junit-jupiter-params:${testLibVersions.junitVer}",
            junitSuite     : "org.junit.platform:junit-platform-suite:${testLibVersions.junitSuiteVer}",
            mockitoLib     : "org.mockito:mockito-inline:${testLibVersions.mockitoInlineVer}",
            mockitoJupiter : "org.mockito:mockito-junit-jupiter:${testLibVersions.mockitoJupiterVer}",
            awaitilityLib  : "org.awaitility:awaitility:${testLibVersions.awaitilityVer}",
            commonsIoLib   : "commons-io:commons-io:${testLibVersions.commonsIoVer}",
            commonsCodecLib: "commons-codec:commons-codec:${testLibVersions.commonsCodecVer}",
            jacksonLib     : "com.fasterxml.jackson.core:jackson-databind:${testLibVersions.jacksonVer}",
            okhttpWsLib    : "com.squareup.okhttp:okhttp-ws:${testLibVersions.okhttpWsVer}",

            rskLllLib      : "co.rsk:lll-compiler:${testLibVersions.rskLllVer}",

            jazzerJunit    : "com.code-intelligence:jazzer-junit:${testLibVersions.jazzerJunitVer}",
    ]

    jmhLibs = [
            jmhCore       : "org.openjdk.jmh:jmh-core:${jmhLibVersions.jmh}",
            jmhAnnotations: "org.openjdk.jmh:jmh-generator-annprocess:${jmhLibVersions.jmh}",
            web3jCore     : "org.web3j:core:${jmhLibVersions.web3j}",
    ]

}

// WARN: consider different setups and sure to not use GPG elements without checksums or without signature file
// in the remote repository (see https://github.com/gradle/gradle/security/advisories/GHSA-j6wc-xfg8-jx2j)
dependencies {
    jmhImplementation project(path: ':rskj-core')
    jmhImplementation "${jmhLibs.jmhCore}"
    jmhImplementation "${jmhLibs.web3jCore}"
    jmhImplementation "${libs.slf4jApiLib}"
    jmhAnnotationProcessor "${jmhLibs.jmhAnnotations}"
    jmhRuntimeOnly "${libs.log4jOverSlf4jLib}"
    jmhRuntimeOnly "${libs.logbackCoreLib}"
    jmhRuntimeOnly "${libs.logbackClassicLib}"

    implementation "${libs.nettyLib}"
    implementation "${libs.spongyCastleLib}"
    implementation "${libs.bouncyCastleLib}"
    implementation "${libs.ethereumLeveldbJniLib}"
    implementation "${libs.rocksdbJniLib}"
    implementation "${libs.slf4jApiLib}"
    implementation "${libs.jacksonLib}"
    implementation "${libs.commonsLang3Lib}"
    implementation "${libs.typesafeConfigLib}"
    implementation "${libs.mapdbLib}"
    implementation "${libs.jsonrpc4jLib}"
    implementation "${libs.jaxwsRtLib}"
    implementation "${libs.picocliLib}"

    implementation "${libs.bitcoinjThinLib}"
    implementation "${libs.rskjNativeLib}"

    runtimeOnly "${libs.log4jOverSlf4jLib}"
    runtimeOnly "${libs.logbackCoreLib}"
    runtimeOnly "${libs.logbackClassicLib}"

    testImplementation "${testLibs.junitLib}"
    testImplementation "${testLibs.junitParams}"
    testImplementation "${testLibs.junitSuite}"
    testImplementation "${testLibs.mockitoLib}"
    testImplementation "${testLibs.mockitoJupiter}"
    testImplementation "${testLibs.awaitilityLib}"
    testImplementation "${testLibs.commonsIoLib}"
    testImplementation "${testLibs.commonsCodecLib}"
    testImplementation "${testLibs.okhttpWsLib}"
    testImplementation "${testLibs.rskLllLib}"

    integrationTestImplementation "${testLibs.junitLib}"
    integrationTestImplementation "${testLibs.junitParams}"
    integrationTestImplementation "${testLibs.junitSuite}"
    integrationTestImplementation "${testLibs.mockitoLib}"
    integrationTestImplementation "${testLibs.mockitoJupiter}"
    integrationTestImplementation "${testLibs.awaitilityLib}"
    integrationTestImplementation "${testLibs.jacksonLib}"
    integrationTestImplementation "${testLibs.okhttpWsLib}"
    integrationTestImplementation "${libs.commonsLang3Lib}"

    fuzzTestImplementation "${libs.bouncyCastleLib}"
    fuzzTestImplementation "${testLibs.junitLib}"
    fuzzTestImplementation "${testLibs.junitParams}"
    fuzzTestImplementation "${testLibs.junitSuite}"
    fuzzTestImplementation "${testLibs.mockitoLib}"
    fuzzTestImplementation "${testLibs.mockitoJupiter}"
    fuzzTestImplementation "${testLibs.awaitilityLib}"
    fuzzTestImplementation "${testLibs.commonsIoLib}"
    fuzzTestImplementation "${testLibs.commonsCodecLib}"
    fuzzTestImplementation "${testLibs.okhttpWsLib}"
    fuzzTestImplementation "${testLibs.rskLllLib}"
    fuzzTestImplementation "${testLibs.jazzerJunit}"
}

javadoc {
    options.author = true
    options.header = "RskJ"
    options.addStringOption('-quiet')
    options.encoding = "UTF-8"
}

publishing {
    publications {
        rskj(MavenPublication) {
            pom {
                from components.java
                licenses {
                    license {
                        name = 'GNU General Public License (GPL) version 3.0'
                        url = 'http://www.gnu.org/licenses/gpl-3.0.txt'
                        distribution = 'repo'
                    }
                }
            }
        }
    }
}

task generateResources {
    def buildInfoFile = 'build-info.properties'

    doLast {
        def generatedDir = new File(buildDir, 'generatedResources')
        mkdir(generatedDir)
        def generated = new File(generatedDir, buildInfoFile)
        def commitHash = gitCommitHash()
        def currentBranch = gitCurrentBranch()
        generated.text = """
            build.hash=$commitHash
            build.branch=$currentBranch
            """
    }
}

task sourcesJar(type: Jar, dependsOn: classes) {
    archiveClassifier = 'sources'
    from sourceSets.main.allSource
}

task javadocJar(type: Jar) {
    archiveClassifier = 'javadoc'
    from javadoc
}

jar {
    dependsOn generateResources
    def commitHash = gitCommitHash()
    def currentBranch = gitCurrentBranch()
    manifest {
        attributes 'Git-Commit': commitHash,
                'Git-Branch': currentBranch
    }
    from sourceSets.main.output.classesDirs
    from sourceSets.main.output.resourcesDir
    from new File(buildDir, 'generatedResources') // Reference the generated resources directory
}

task generatePom(dependsOn: jar) {
    dependsOn generatePomFileForRskjPublication

    def jarName = jar.outputs.files.singleFile.name
    def pomFile = layout.buildDirectory.dir("${jarName.take(jarName.lastIndexOf('.'))}.pom").get().asFile
    ext.file = pomFile

    doLast {
        copy {
            from "$buildDir/publications/rskj/pom-default.xml"
            into pomFile.parentFile
            rename 'pom-default.xml', pomFile.name
        }
    }
}

task fatJar(type: Jar, dependsOn: jar) {
    archiveClassifier = 'all'
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE

    manifest {
        attributes 'Main-Class': "$application.mainClass"
    }

    exclude 'META-INF/*.SF', 'META-INF/*.DSA', 'META-INF/*.RSA'
    exclude 'module-info.class'

    for (def jar in configurations.runtimeClasspath.findAll { it.name.endsWith('jar') }.collect { zipTree(it) }) {
        from(jar) {
            eachFile { details -> amendPathIfNeeded(details) }
        }
    }

    with jar
}

task jmhJar(type: Jar) {
    from sourceSets.jmh.output
    archiveClassifier = 'jmh'
}

task jmh(type: JavaExec) {
    doLast {
        mkdir "${buildDir}/reports/jmh"
    }

    classpath = sourceSets.jmh.runtimeClasspath

    // provide -PjmhArgs="<regular jmh parameters format>", ie: -PjmhArgs="-wi 5 -i 5 -f 1 -p suite=e2e -p host=http://localhost:4444 co.rsk.jmh.web3.BenchmarkWeb3"
    if (project.hasProperty('jmhArgs')) {
        mainClass = 'org.openjdk.jmh.Main'
        args(jmhArgs.split("\\s+"))
    }
    // provide predefined Benchmark Runner task and optionally other known parameters, ie: -Pbenchmark=BenchmarkWeb3E2ERunner -Phost=http://localhost:4444 -Pnetwork=regtest
    else if (project.hasProperty('benchmark')) {
        mainClass = "co.rsk.jmh.runners.${project.getProperty("benchmark")}"

        def customArgs = []

        if (project.hasProperty('host')) {
            customArgs << "-p" << "host=${project.getProperty("host")}"
        }

        if (project.hasProperty('config')) {
            customArgs << "-p" << "config=${project.getProperty("config")}"
        }

        args(customArgs)
    }

}

tasks.withType(Tar) {
    compression = Compression.GZIP
    archiveExtension.set('tar.gz')
}

artifacts {
    archives sourcesJar
    archives javadocJar
    archives jar
    archives(generatePom.file) {
        type 'text'
        builtBy generatePom
    }
    archives fatJar
    archives distTar
}

static def gitCurrentBranch() {
    def process = "git rev-parse --abbrev-ref HEAD".execute()
    return process.text.trim()
}

static def gitCommitHash() {
    def process = "git rev-parse --short HEAD".execute()
    return process.text.trim()
}

static def amendPathIfNeeded(details) {
    def uPath = details.path.toUpperCase()
    if (uPath.startsWith("META-INF/LICENSE") || uPath.startsWith("META-INF/NOTICE")) {
        def originalFile = details.file as File
        def jarName = originalFile.parentFile.parentFile.name.split(".jar")[0]
        def newPath = originalFile.parentFile.name + "/" + jarName + "_" + originalFile.name
        details.path = newPath
    }
}

task checkstyleAll {
    group = 'Verification'
    description = 'Run all Checkstyle checks'
    dependsOn 'checkstyleMain', 'checkstyleTest', 'checkstyleJmh', 'checkstyleIntegrationTest', 'checkstyleFuzz'
}

task checkstyleFile(type: Checkstyle) {
    group = 'Verification'
    description = 'Run Checkstyle on specific file(s) (use -PfilePath=file1.java or -PfilePath=file1.java,file2.java)'
    maxWarnings = 0
}

task spotlessAll {
    group = 'Verification'
    description = 'Run all Spotless checks'
    dependsOn 'spotlessJavaCheck'
}
